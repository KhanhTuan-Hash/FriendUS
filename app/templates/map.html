{% extends "layout.html" %}

{% block head %}
{{ super() }}
<!-- Leaflet & Plugins -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
{% endblock %}

{% block content %}
<style>
    /* --- FULL SCREEN MAP CONTAINER --- */
    .map-wrapper {
        position: relative;
        width: 100%;
        height: calc(100vh - 56px); /* Adjust based on your navbar height */
        overflow: hidden;
    }

    #map {
        width: 100%;
        height: 100%;
        z-index: 1;
        background: #e9ecef;
    }

    /* --- FLOATING SEARCH BAR --- */
    .search-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 2000; /* Increased Z-Index to ensure it's on top */
        width: 380px;
        max-width: 85vw;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        font-family: 'Segoe UI', sans-serif;
    }

    .search-box {
        display: flex;
        align-items: center;
        padding: 5px 15px;
    }

    .search-box input {
        border: none;
        flex: 1;
        padding: 10px;
        font-size: 16px;
        outline: none;
    }

    .search-box i {
        color: #666;
        font-size: 18px;
    }

    .search-results {
        border-top: 1px solid #eee;
        max-height: 350px;
        overflow-y: auto;
        display: none; /* Hidden by default */
        border-radius: 0 0 8px 8px;
        background: white;
    }

    .result-item {
        padding: 12px 15px;
        cursor: pointer;
        border-bottom: 1px solid #f8f9fa;
        transition: background 0.2s;
    }

    .result-item:hover {
        background-color: #f1f3f5;
    }

    .result-item .name { font-weight: 600; color: #212529; font-size: 14px; display: block; }
    .result-item .address { color: #6c757d; font-size: 12px; display: block; margin-top: 2px; }

    /* --- FLOATING CONTROLS (RIGHT SIDE) --- */
    .floating-controls {
        position: absolute;
        bottom: 30px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .control-btn {
        width: 44px;
        height: 44px;
        background: white;
        border-radius: 50%;
        border: none;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        color: #495057;
        cursor: pointer;
        transition: all 0.2s;
    }

    .control-btn:hover {
        background: #f8f9fa;
        color: #0d6efd;
        transform: translateY(-2px);
    }

    /* --- ROUTING PANEL OVERRIDE --- */
    .leaflet-routing-container {
        position: absolute !important;
        top: 80px !important;
        left: 20px !important; /* Move to left below search */
        right: auto !important;
        width: 380px !important;
        max-height: 60vh !important;
        border-radius: 8px !important;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
        border: none !important;
        z-index: 1999 !important; /* High Z-index */
        font-family: 'Segoe UI', sans-serif !important;
        display: none; /* Hidden initially */
        background: white;
    }
    
    .leaflet-routing-container.active {
        display: block;
    }

    /* Custom scrollbar for results */
    .search-results::-webkit-scrollbar { width: 6px; }
    .search-results::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }

    /* --- POPUP STYLE --- */
    .custom-popup .leaflet-popup-content-wrapper {
        border-radius: 8px;
        box-shadow: 0 4px 14px rgba(0,0,0,0.2);
    }
    .popup-btn {
        display: block;
        width: 100%;
        margin-top: 8px;
        border-radius: 4px;
        font-size: 13px;
        padding: 6px;
    }

    /* Mobile Adaptations */
    @media (max-width: 576px) {
        .search-container { width: calc(100% - 40px); top: 10px; }
        .leaflet-routing-container { width: calc(100% - 40px) !important; top: 70px !important; }
        .floating-controls { bottom: 80px; right: 10px; }
    }
</style>

<div class="map-wrapper">
    <!-- Floating Search Bar -->
    <div class="search-container">
        <div class="search-box">
            <i class="bi bi-search"></i>
            <input type="text" id="vm-search-input" placeholder="Search VietMap (e.g., Cafe)..." autocomplete="off">
            <i class="bi bi-x-circle-fill text-secondary" id="clear-search" style="cursor: pointer; display: none; font-size: 16px;"></i>
        </div>
        <div id="vm-search-results" class="search-results"></div>
    </div>

    <!-- Floating Action Buttons -->
    <div class="floating-controls">
        <button class="control-btn" id="btn-locate" title="Find My Location">
            <i class="bi bi-crosshair"></i>
        </button>
        <!-- Zoom controls will be handled by Leaflet, positioned bottomright -->
    </div>

    <!-- Map Div -->
    <div id="map" 
         data-apikey="{{ vietmap_api_key }}"
         data-default-lat="{{ default_lat if default_lat is defined and default_lat is not none else '' }}"
         data-default-lon="{{ default_lon if default_lon is defined and default_lon is not none else '' }}"
         data-locations='{{ locations_data|tojson|safe if locations_data is defined else "[]" }}'
    ></div>
</div>
{% endblock %}

{% block scripts %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const mapEl = document.getElementById('map');
        // Ensure apiKey is treated as a string and trimmed
        const apiKey = (mapEl.dataset.apikey || "").trim();

        console.log("Initializing Map. API Key present:", !!apiKey);

        // --- 1. INITIALIZE MAP ---
        let defLat = parseFloat(mapEl.dataset.defaultLat) || 10.762622;
        let defLon = parseFloat(mapEl.dataset.defaultLon) || 106.660172;
        let defZoom = (mapEl.dataset.defaultLat) ? 16 : 13;

        const map = L.map('map', { 
            zoomControl: false, 
            attributionControl: false 
        }).setView([defLat, defLon], defZoom);

        L.control.zoom({ position: 'bottomright' }).addTo(map);
        L.control.attribution({ prefix: false }).addAttribution('&copy; VietMap &copy; OSM').addTo(map);

        // --- 2. ADD TILES ---
        if (apiKey && apiKey !== "None") {
            L.tileLayer(`https://maps.vietmap.vn/tm/{z}/{x}/{y}@2x.png?apikey=${apiKey}`, {
                maxZoom: 20,
                minZoom: 5
            }).addTo(map);
        } else {
            console.warn("VietMap API Key Missing - Falling back to OSM");
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        }

        // --- 3. VIETMAP ROUTING ENGINE ---
        L.Routing.VietMap = L.Class.extend({
            initialize: function(apiKey) { this._apiKey = apiKey; },
            route: function(waypoints, callback, context, options) {
                if (waypoints.length < 2) return;
                const start = waypoints[0].latLng;
                const end = waypoints[waypoints.length - 1].latLng;
                
                // If no API key, fail gracefully
                if (!this._apiKey) {
                    console.error("Routing requires API Key");
                    return callback.call(context, { status: 403, message: "Missing API Key" });
                }

                const url = `https://maps.vietmap.vn/api/route?api-version=1.1&apikey=${this._apiKey}&point=${start.lat},${start.lng}&point=${end.lat},${end.lng}&vehicle=car`;

                fetch(url)
                    .then(r => r.json())
                    .then(data => {
                        if (!data.paths || data.paths.length === 0) {
                            return callback.call(context, { status: 404, message: "No route found." });
                        }
                        const path = data.paths[0];
                        const coordinates = this._decodePolyline(path.points);

                        const result = [{
                            name: "VietMap Route",
                            summary: {
                                totalDistance: path.distance,
                                totalTime: path.time / 1000 
                            },
                            coordinates: coordinates,
                            instructions: path.instructions.map(inst => ({
                                distance: inst.distance,
                                time: inst.time / 1000,
                                text: inst.text,
                                type: inst.sign
                            })),
                            waypoints: waypoints
                        }];

                        callback.call(context, null, result);
                    })
                    .catch(err => {
                        console.error("Routing Error:", err);
                        callback.call(context, { status: 500, message: err.message });
                    });
            },
            _decodePolyline: function(str, precision) {
                var index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null, latitude_change, longitude_change, factor = Math.pow(10, precision || 5);
                while (index < str.length) {
                    byte = null; shift = 0; result = 0;
                    do { byte = str.charCodeAt(index++) - 63; result |= (byte & 0x1f) << shift; shift += 5; } while (byte >= 0x20);
                    latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
                    shift = result = 0;
                    do { byte = str.charCodeAt(index++) - 63; result |= (byte & 0x1f) << shift; shift += 5; } while (byte >= 0x20);
                    longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
                    lat += latitude_change; lng += longitude_change;
                    coordinates.push(L.latLng(lat / factor, lng / factor));
                }
                return coordinates;
            }
        });

        const routingControl = L.Routing.control({
            router: new L.Routing.VietMap(apiKey),
            plan: L.Routing.plan([], {
                createMarker: function(i, wp) {
                    return L.marker(wp.latLng, { draggable: true });
                }
            }),
            lineOptions: { styles: [{ color: '#0d6efd', opacity: 0.8, weight: 6 }] },
            containerClassName: 'leaflet-routing-container',
            addWaypoints: false,
            routeWhileDragging: false,
            show: false
        }).addTo(map);

        // --- 4. SEARCH FUNCTIONALITY (Fixed) ---
        const searchInput = document.getElementById('vm-search-input');
        const searchResults = document.getElementById('vm-search-results');
        const clearBtn = document.getElementById('clear-search');
        let searchTimeout;
        let searchMarker;

        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();
            
            if (query.length > 0) clearBtn.style.display = 'block';
            else { 
                clearBtn.style.display = 'none'; 
                searchResults.style.display = 'none'; 
                return; 
            }

            // Debounce
            searchTimeout = setTimeout(() => {
                if (query.length < 2) return;
                
                if (!apiKey) {
                    console.error("Cannot search: API Key is missing");
                    return;
                }

                console.log("Searching for:", query);
                const searchUrl = `https://maps.vietmap.vn/api/search/v3?apikey=${apiKey}&text=${encodeURIComponent(query)}`;

                fetch(searchUrl)
                    .then(r => r.json())
                    .then(data => {
                        searchResults.innerHTML = '';
                        // Normalize data: sometimes it's array, sometimes {data: [...]}
                        let places = Array.isArray(data) ? data : (data.data || []);
                        
                        if (places.length > 0) {
                            searchResults.style.display = 'block';
                            places.forEach(place => {
                                const div = document.createElement('div');
                                div.className = 'result-item';
                                div.innerHTML = `<span class="name">${place.name}</span><span class="address">${place.address}</span>`;
                                div.onclick = () => {
                                    // Handle coordinate variations
                                    let lat, lng;
                                    if (place.location) { lat = place.location.lat; lng = place.location.lng; }
                                    else { lat = place.lat; lng = place.lng; }
                                    
                                    if (lat && lng) {
                                        selectLocation(lat, lng, place.name, place.address);
                                    } else {
                                        console.error("Invalid coordinates for place:", place);
                                    }
                                };
                                searchResults.appendChild(div);
                            });
                        } else {
                            searchResults.style.display = 'none';
                        }
                    })
                    .catch(e => {
                        console.error("Search API Error:", e);
                    });
            }, 400); // Increased debounce slightly
        });

        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            searchResults.style.display = 'none';
            clearBtn.style.display = 'none';
            if (searchMarker) map.removeLayer(searchMarker);
            document.querySelector('.leaflet-routing-container').classList.remove('active');
            routingControl.setWaypoints([]); 
        });

        function selectLocation(lat, lng, name, address) {
            searchResults.style.display = 'none';
            searchInput.value = name;
            
            map.flyTo([lat, lng], 17);

            if (searchMarker) map.removeLayer(searchMarker);
            searchMarker = L.marker([lat, lng]).addTo(map)
                .bindPopup(createPopupContent(lat, lng, name, address))
                .openPopup();
        }

        // --- 5. FIND MY LOCATION (Fixed) ---
        const locateBtn = document.getElementById('btn-locate');
        locateBtn.addEventListener('click', () => {
            if (!navigator.geolocation) return alert("Geolocation not supported by your browser.");
            
            const originalIcon = locateBtn.innerHTML;
            locateBtn.innerHTML = '<div class="spinner-border spinner-border-sm text-primary"></div>';
            locateBtn.disabled = true;

            navigator.geolocation.getCurrentPosition(pos => {
                const { latitude, longitude } = pos.coords;
                console.log("Got location:", latitude, longitude);

                // 1. Move Map Immediately (Don't wait for API)
                map.flyTo([latitude, longitude], 16);
                
                // 2. Fetch Address (Reverse Geocode)
                if (apiKey) {
                    fetch(`https://maps.vietmap.vn/api/reverse/v3?apikey=${apiKey}&lat=${latitude}&lng=${longitude}`)
                    .then(r => r.json())
                    .then(data => {
                         let addr = "Your Location";
                         // Handle response variations
                         if (Array.isArray(data) && data[0]) addr = data[0].address;
                         else if (data.address) addr = data.address;

                         L.popup()
                            .setLatLng([latitude, longitude])
                            .setContent(`<strong>You are here</strong><br><small>${addr}</small>`)
                            .openOn(map);
                    })
                    .catch(e => console.error("Reverse Geocode Error:", e))
                    .finally(() => {
                        locateBtn.innerHTML = originalIcon;
                        locateBtn.disabled = false;
                    });
                } else {
                    // No API key, just show "You are here"
                    L.marker([latitude, longitude]).addTo(map).bindPopup("You are here").openPopup();
                    locateBtn.innerHTML = originalIcon;
                    locateBtn.disabled = false;
                }

            }, err => {
                console.error("Geolocation Error:", err);
                alert("Error finding location: " + err.message);
                locateBtn.innerHTML = originalIcon;
                locateBtn.disabled = false;
            }, {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            });
        });

        // --- 6. CLICK MAP to REVERSE GEOCODE ---
        let clickMarker;
        map.on('click', function(e) {
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            if (clickMarker) map.removeLayer(clickMarker);
            
            clickMarker = L.marker([lat, lng]).addTo(map);
            
            if (!apiKey) {
                clickMarker.bindPopup(createPopupContent(lat, lng, "Location", `${lat.toFixed(5)}, ${lng.toFixed(5)}`)).openPopup();
                return;
            }

            clickMarker.bindPopup('<div class="text-center p-2">Fetching address...<br><div class="spinner-border spinner-border-sm text-primary mt-1"></div></div>').openPopup();

            fetch(`https://maps.vietmap.vn/api/reverse/v3?apikey=${apiKey}&lat=${lat}&lng=${lng}`)
                .then(r => r.json())
                .then(data => {
                    let name = "Selected Location";
                    let address = "Unknown Address";

                    if (Array.isArray(data) && data[0]) {
                        address = data[0].address;
                        name = data[0].name || name;
                    } else if (data.address) {
                        address = data.address;
                    }

                    clickMarker.setPopupContent(createPopupContent(lat, lng, name, address));
                })
                .catch(err => {
                    clickMarker.setPopupContent(createPopupContent(lat, lng, "Selected Location", `${lat.toFixed(5)}, ${lng.toFixed(5)}`));
                });
        });

        // --- 7. UTILS ---
        function createPopupContent(lat, lng, name, address) {
            const safeName = (name || "Location").replace(/'/g, "&apos;");
            const safeAddr = (address || "").replace(/'/g, "&apos;");

            const div = document.createElement('div');
            div.className = 'custom-popup';
            div.innerHTML = `
                <div class="text-center" style="min-width: 200px;">
                    <h6 class="mb-1 text-primary fw-bold">${safeName}</h6>
                    <p class="small text-muted mb-2">${safeAddr}</p>
                    <div class="d-grid gap-2">
                        <button class="btn btn-primary btn-sm popup-btn" onclick="saveLocation(${lat}, ${lng}, '${safeName}', '${safeAddr}')">
                            <i class="bi bi-bookmark-plus"></i> Save Location
                        </button>
                        <button class="btn btn-outline-success btn-sm popup-btn" onclick="routeHere(${lat}, ${lng})">
                            <i class="bi bi-sign-turn-right"></i> Directions Here
                        </button>
                    </div>
                </div>
            `;
            return div;
        }

        window.saveLocation = function(lat, lon, name, addr) {
            fetch('{{ url_for("map.create_location_on_click") }}', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ lat, lon, name, address: addr })
            })
            .then(r => r.json())
            .then(data => { if (data.url) window.location.href = data.url; })
            .catch(err => alert("Error saving location"));
        };

        window.routeHere = function(destLat, destLon) {
            if (!navigator.geolocation) return alert("Geolocation not supported.");
            
            map.closePopup();
            const loadingPopup = L.popup().setLatLng([destLat, destLon]).setContent("Locating you...").openOn(map);

            navigator.geolocation.getCurrentPosition(pos => {
                map.removeLayer(loadingPopup);
                const userLat = pos.coords.latitude;
                const userLon = pos.coords.longitude;

                document.querySelector('.leaflet-routing-container').classList.add('active');
                
                routingControl.setWaypoints([
                    L.latLng(userLat, userLon),
                    L.latLng(destLat, destLon)
                ]);
                
                map.fitBounds(L.latLngBounds([userLat, userLon], [destLat, destLon]), { padding: [50, 50] });

            }, err => {
                alert("Could not get your location: " + err.message);
                map.removeLayer(loadingPopup);
            });
        };

        // --- 8. LOAD MARKERS ---
        try {
            const dbLocations = JSON.parse(mapEl.dataset.locations);
            if (dbLocations.length > 0) {
                const markers = L.markerClusterGroup();
                dbLocations.forEach(loc => {
                    if(loc.lat && loc.lon) {
                        const stars = '★'.repeat(Math.round(loc.rating)) + '☆'.repeat(5 - Math.round(loc.rating));
                        markers.addLayer(
                            L.marker([loc.lat, loc.lon])
                            .bindPopup(`
                                <div style="min-width:180px">
                                    <h6 class="fw-bold mb-1">${loc.name}</h6>
                                    <div class="text-warning small mb-1">${stars}</div>
                                    <p class="small text-muted text-truncate" style="max-width:180px">${loc.desc || ''}</p>
                                    <a href="${loc.url}" class="btn btn-sm btn-outline-primary w-100">Details</a>
                                </div>
                            `)
                        );
                    }
                });
                map.addLayer(markers);
            }
        } catch(e) { console.error("Error parsing DB locations", e); }
    });
</script>
{% endblock %}